package org.davidmoten.gt;

import java.math.BigInteger;

public final class Hilbert {

    private Hilbert() {
        // prevent instantiation
    }

    /**
     * Convert the Hilbert index into an N-dimensional point expressed as a
     * vector of uints.
     *
     * Note: In Skilling's paper, this function is named TransposetoAxes.
     * 
     * @param transposedIndex
     *            The Hilbert index stored in transposed form.
     * @param bits
     *            Number of bits per coordinate.
     * @return Point in N-space.
     */
    public static long[] axes(final long[] transposedIndex, final int bits) {
        final long[] result = transposedIndex.clone();
        final int dims = result.length;
        grayDecode(result, dims);
        undoExcessWork(result, dims, bits);
        return result;
    }

    private static void grayDecode(final long[] result, final int dims) {
        final long swap = result[dims - 1] >>> 1;
        // Corrected error in Skilling's paper on the following line. The
        // appendix had i >= 0 leading to negative array index.
        for (int i = dims - 1; i > 0; i--)
            result[i] ^= result[i - 1];
        result[0] ^= swap;
    }

    private static void undoExcessWork(final long[] result, final int dims, final int bits) {
        for (long bit = 2, n = 1; n != bits; bit <<= 1, ++n) {
            final long mask = bit - 1;
            for (int i = dims - 1; i >= 0; i--)
                if ((result[i] & bit) != 0)
                    result[0] ^= mask; // invert
                else
                    swapBits(result, mask, i);
        }
    }

    /**
     * Given the axes (coordinates) of a point in N-Dimensional space, find the
     * distance to that point along the Hilbert curve. That distance will be
     * transposed; broken into pieces and distributed into an array.
     *
     * The number of dimensions is the length of the hilbertAxes array.
     *
     * Note: In Skilling's paper, this function is called AxestoTranspose.
     * 
     * @param hilbertAxes
     *            Point in N-space.
     * @param bits
     *            Depth of the Hilbert curve. If bits is one, this is the
     *            top-level Hilbert curve.
     * @return The Hilbert distance (or index) as a transposed Hilbert index.
     */
    public static long[] transposedIndex(final long[] hilbertAxes, final int bits) {
        final long[] result = hilbertAxes.clone();
        final int dims = hilbertAxes.length;
        final long maxBit = 1L << (bits - 1);
        inverseUndo(result, dims, maxBit);
        grayEncode(result, dims, maxBit);
        return result;
    }

    public static BigInteger untranspose(long[] transposedIndex, int bits, boolean reverseOrder) {
        byte[] interleavedBytes = interleave(transposedIndex, bits, reverseOrder);
        return new BigInteger(interleavedBytes);
    }

    /// <summary>
    /// Interleave the bits of an unsigned vector and generate a byte array in
    /// little-endian order, as needed for the BigInteger constructor.
    ///
    /// The high-order bit from the last number in vector becomes the high-order
    /// bit of last byte in the generated byte array.
    /// The high-order bit of the next to last number becomes the second
    /// highest-ordered bit in the last byte in the generated byte array.
    /// The low-order bit of the first number becomes the low order bit of the
    /// first byte in the new array.
    ///
    /// NOTE: For a given bitDepth and number of dimensions, many of the
    /// intermediate values can be precomputed:
    /// iFromUintVector
    /// iFromUintBit
    /// iToByteVector
    /// iToByteBit
    /// This is done in the method interleaver.
    /// </summary>
    public static byte[] interleave(long[] vector, int bitDepth, boolean reverseOrder) {
        // The individual bytes in the value array must be created in
        // little-endian order, from lowest-order byte to highest-order byte
        // in order to be useful when creating a BigInteger.
        int dimensions = vector.length; // Pull member access out of loop!
        int bytesNeeded = (bitDepth * dimensions) >> 3;
        byte[] byteVector = new byte[bytesNeeded + 1]; // BigInteger seems to
                                                       // need an extra, zero
                                                       // byte at the end. Might
                                                       // be for the sign bit.
        int numBits = dimensions * bitDepth;

        for (int iBit = 0; iBit < numBits; iBit++) {
            int iFromUintVector = iBit % dimensions;
            int iFromUintBit = iBit / dimensions;
            int iToByteVector = iBit >> 3;
            int iToByteBit = iBit & 0x7;

            reverseOrder = false; // DEBUG
            int indexToUse = reverseOrder ? dimensions - iFromUintVector - 1 : iFromUintVector;

            byte bit = (byte) (((vector[indexToUse] >> iFromUintBit) & 1) << iToByteBit);
            byteVector[iToByteVector] |= bit;
        }
        return byteVector;
    }

    private static void inverseUndo(final long[] result, final int dims, final long maxBit) {
        for (long bit = maxBit; bit != 0; bit >>>= 1) {
            final long mask = bit - 1;
            for (int i = 0; i < dims; i++)
                if ((result[i] & bit) != 0)
                    result[0] ^= mask; // invert
                else
                    swapBits(result, mask, i);
        } // exchange
    }

    private static void grayEncode(final long[] result, final int dims, final long maxBit) {
        for (int i = 1; i < dims; i++)
            result[i] ^= result[i - 1];
        long mask = 0;
        for (long bit = maxBit; bit != 0; bit >>>= 1)
            if ((result[dims - 1] & bit) != 0)
                mask ^= bit - 1;
        for (int i = 0; i < dims; i++)
            result[i] ^= mask;
    }

    private static void swapBits(final long[] array, final long mask, final int index) {
        final long swap = (array[0] ^ array[index]) & mask;
        array[0] ^= swap;
        array[index] ^= swap;
    }

}
