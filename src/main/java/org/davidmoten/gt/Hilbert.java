package org.davidmoten.gt;

import java.math.BigInteger;

public final class Hilbert {

    private Hilbert() {
        // prevent instantiation
    }

    /**
     * Convert the Hilbert index into an N-dimensional point expressed as a
     * vector of uints.
     *
     * Note: In Skilling's paper, this function is named TransposetoAxes.
     * 
     * @param transposedIndex
     *            The Hilbert index stored in transposed form.
     * @param bits
     *            Number of bits per coordinate.
     * @return Point in N-space.
     */
    public static long[] point(final long[] transposedIndex, final int bits) {
        final long[] result = transposedIndex.clone();
        final int dims = result.length;
        grayDecode(result, dims);
        undoExcessWork(result, dims, bits);
        return result;
    }

    private static void grayDecode(final long[] result, final int dims) {
        final long swap = result[dims - 1] >>> 1;
        // Corrected error in Skilling's paper on the following line. The
        // appendix had i >= 0 leading to negative array index.
        for (int i = dims - 1; i > 0; i--)
            result[i] ^= result[i - 1];
        result[0] ^= swap;
    }

    private static void undoExcessWork(final long[] result, final int dims, final int bits) {
        for (long bit = 2, n = 1; n != bits; bit <<= 1, ++n) {
            final long mask = bit - 1;
            for (int i = dims - 1; i >= 0; i--)
                if ((result[i] & bit) != 0)
                    result[0] ^= mask; // invert
                else
                    swapBits(result, mask, i);
        }
    }

    /**
     * Given the axes (coordinates) of a point in N-Dimensional space, find the
     * distance to that point along the Hilbert curve. That distance will be
     * transposed; broken into pieces and distributed into an array.
     *
     * The number of dimensions is the length of the hilbertAxes array.
     *
     * Note: In Skilling's paper, this function is called AxestoTranspose.
     * 
     * @param point
     *            Point in N-space.
     * @param bits
     *            Depth of the Hilbert curve. If bits is one, this is the
     *            top-level Hilbert curve.
     * @return The Hilbert distance (or index) as a transposed Hilbert index.
     */
    public static long[] transposedIndex(final long[] point, final int bits) {
        final long[] result = point.clone();
        final int dims = point.length;
        final long maxBit = 1L << (bits - 1);
        inverseUndo(result, dims, maxBit);
        grayEncode(result, dims, maxBit);
        return result;
    }

    public static BigInteger untranspose(long[] transposedIndex, int bits, boolean reverseOrder) {
        byte[] interleavedBytes = interleave(transposedIndex, bits, reverseOrder);
        return new BigInteger(interleavedBytes);
    }

    /// <summary>
    /// Interleave the bits of an unsigned vector and generate a byte array in
    /// little-endian order, as needed for the BigInteger constructor.
    ///
    /// The high-order bit from the last number in vector becomes the high-order
    /// bit of last byte in the generated byte array.
    /// The high-order bit of the next to last number becomes the second
    /// highest-ordered bit in the last byte in the generated byte array.
    /// The low-order bit of the first number becomes the low order bit of the
    /// first byte in the new array.
    ///
    /// NOTE: For a given bitDepth and number of dimensions, many of the
    /// intermediate values can be precomputed:
    /// iFromUintVector
    /// iFromUintBit
    /// iToByteVector
    /// iToByteBit
    /// This is done in the method interleaver.
    /// </summary>
    public static byte[] interleave(long[] vector, int bitDepth, boolean reverseOrder) {
        // The individual bytes in the value array must be created in
        // little-endian order, from lowest-order byte to highest-order byte
        // in order to be useful when creating a BigInteger.
        int dimensions = vector.length; // Pull member access out of loop!
        int bytesNeeded = (bitDepth * dimensions) >> 3;
        byte[] byteVector = new byte[bytesNeeded + 1]; // BigInteger seems to
                                                       // need an extra, zero
                                                       // byte at the end. Might
                                                       // be for the sign bit.
        int numBits = dimensions * bitDepth;

        for (int iBit = 0; iBit < numBits; iBit++) {
            int iFromUintVector = iBit % dimensions;
            int iFromUintBit = iBit / dimensions;
            int iToByteVector = iBit >> 3;
            int iToByteBit = iBit & 0x7;

            reverseOrder = false; // DEBUG
            int indexToUse = reverseOrder ? dimensions - iFromUintVector - 1 : iFromUintVector;

            byte bit = (byte) (((vector[indexToUse] >> iFromUintBit) & 1) << iToByteBit);
            byteVector[iToByteVector] |= bit;
        }
        return byteVector;
    }

    private static void inverseUndo(final long[] result, final int dims, final long maxBit) {
        for (long bit = maxBit; bit != 0; bit >>>= 1) {
            final long mask = bit - 1;
            for (int i = 0; i < dims; i++)
                if ((result[i] & bit) != 0)
                    result[0] ^= mask; // invert
                else
                    swapBits(result, mask, i);
        } // exchange
    }

    private static void grayEncode(final long[] result, final int dims, final long maxBit) {
        for (int i = 1; i < dims; i++)
            result[i] ^= result[i - 1];
        long mask = 0;
        for (long bit = maxBit; bit != 0; bit >>>= 1)
            if ((result[dims - 1] & bit) != 0)
                mask ^= bit - 1;
        for (int i = 0; i < dims; i++)
            result[i] ^= mask;
    }

    private static void swapBits(final long[] array, final long mask, final int index) {
        final long swap = (array[0] ^ array[index]) & mask;
        array[0] ^= swap;
        array[index] ^= swap;
    }

    /// <summary>
    /// Convert a BigInteger into an array of bits.
    /// </summary>
    /// <param name="N">BigInteger to convert.</param>
    /// <returns>Array of ones and zeroes. The first element is the low bit of
    /// the BigInteger.
    /// The last bit is the sign bit.
    /// </returns>
    public static int[] unpackBigInteger(BigInteger N) {
        byte[] bytes = N.toByteArray();
        int[] bits = new int[bytes.length << 3];
        int bitIndex = 0;
        for (byte b : bytes) {
            byte bShift = b;
            for (int bitInByte = 0; bitInByte < 8; bitInByte++) {
                bits[bitIndex++] = bShift & 1;
                bShift >>= 1;
            }
        }
        return bits;
    }

    /// <summary>
    /// Convert a BigInteger into an array of bits using the supplied array to
    /// hold the results.
    /// </summary>
    /// <param name="N">BigInteger to convert.</param>
    /// <param name="bits">Array to hold bits from result.
    /// If the BigInteger has more bits than this, the higher bits are
    /// dropped.</param>
    /// <returns>Array of ones and zeroes. The first element is the low bit of
    /// the BigInteger.
    /// The last bit is only the sign bit if the size of the supplied array
    /// times eight exactly matches the number of bytes returned by
    /// BigInteger.ToByteArray.
    /// </returns>
    public static int[] unpackBigInteger(BigInteger N, int[] bits) {
        byte[] bytes = N.toByteArray();
        int bitIndex = 0;
        for (byte b : bytes) {
            byte bShift = b;
            for (int bitInByte = 0; bitInByte < 8 && (bitIndex < bits.length); bitInByte++) {
                bits[bitIndex++] = bShift & 1;
                bShift >>= 1;
            }
            if (bitIndex >= bits.length)
                break;
        }
        return bits;
    }

    public static long[] uninterleave(BigInteger grayCode, int bitDepth, int dimensions,
            boolean reverseOrder) {
        // TODO: There must be a more efficient way to delaminate, but I can't
        // figure it out.
        long[] vector = new long[dimensions];
        int numBits = dimensions * bitDepth;
        int[] bits = unpackBigInteger(grayCode, new int[numBits]);
        int bitIndex = 0;
        int startDimension = reverseOrder ? dimensions - 1 : 0;
        int stopDimension = reverseOrder ? -1 : dimensions;
        int dimIncrement = reverseOrder ? -1 : 1;
        for (int bitNumber = 0; bitNumber < bitDepth; bitNumber++) {
            for (int dimension = startDimension; dimension != stopDimension; dimension += dimIncrement) {
                vector[dimension] = vector[dimension] | (long) (bits[bitIndex++] << bitNumber);
            }
        }
        return vector;
    }

}
